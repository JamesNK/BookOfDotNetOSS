{
  "docs/nuget.html": {
    "href": "docs/nuget.html",
    "title": "NuGet | The Book of .NET OSS",
    "keywords": "NuGet NuGet is a package manager for the .NET eco-system and is the primary way that .NET OSS projects are discovered and acquired by developers. NuGet packages are generally hosted on nuget.org, a free service provided by Microsoft for hosting NuGet packages, but you can publish to custom NuGet services like MyGet and VSTS Package Service. Creating a NuGet Package A NuGet package ( *.nupkg ) is basically a zip file containing .NET assemblies and associated metadata. There are two main ways to create a NuGet package. The newer and recommended way is to create a package from a SDK-style project (project file the content starts with <Project Sdk=\"Microsoft.NET.Sdk\"> ). Assemblies and targets are automatically added to the package and remaining metadata, e.g. package name and version number, is added to the MSBuild file. Compiling with the pack command outputs a *.nupkg file instead of assemblies. <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>netstandard2.0</TargetFramework> <AssemblyName>Contoso.Api</AssemblyName> <PackageVersion>1.1.0</PackageVersion> <Authors>John Doe</Authors> </PropertyGroup> </Project> The older way of creating a NuGet package is with a *.nuspec file and the nuget.exe command line tool. A nuspec file gives you a lot of control but you must carefully specify what assemblies and targets to include in the final NuGet package, and it is easy to make a mistake or for someone to forget to update the nuspec when making changes. The advantage of a nuspec is you can use it create NuGet packages for frameworks that do not yet support an SDK-style project file. ✔️ CONSIDER using a SDK-style project file to create the NuGet package. ✔️ CONSIDER setting up SourceLink to add source control metadata to your assemblies and NuGet package. More Information Creating NuGet packages Migrate from packages.config to PackageReference Package Dependences NuGet package dependencies are covered in detail here . Important NuGet Package Metadata A NuGet package has a lot of associated metadata. This is the metadata that every public OSS project should provide: MSBuild Property name Nuspec name Description PackageId id The package identifier. Prefix can be reserved if it meets the criteria PackageVersion version NuGet package version. Read more about it here . Title title A human-friendly title of the package. It defaults to the PackageId . Description description A long description of the package displayed in UI. Authors authors A comma-separated list of packages authors, matching the profile names on nuget.org. PackageTags tags A space-delimited list of tags and keywords that describe the package. These are used when searching for packages. PackageIconUrl iconUrl A URL for an image to use as the icon for the package. URL should be HTTPS and the image should be 64x64 and have a transparent background. PackageProjectUrl projectUrl A URL for the project homepage or source repository. PackageLicenseUrl licenseUrl A URL to the project license. Can be the URL to the LICENSE file in source control. ✔️ CONSIDER choosing a NuGet package name with a prefix that meets NuGet's prefix reservation criteria . ✔️ CONSIDER using the LICENSE file in source control as the LicenseUrl , e.g. https://github.com/JamesNK/Newtonsoft.Json/blob/master/LICENSE.md ✔️ DO use a HTTPS href to your package icon. Sites like nuget.org run with HTTPS enabled and displaying a non-HTTPS image will create a mixed content warning. ✔️ DO use a package icon image that is 64x64 and has a transparent background for best viewing results. More Information .nuspec reference Pre-release Packages NuGet packages with a version suffix are considered pre-release. By default the NuGet Package Manager UI shows stable releases unless a user opts-in to pre-release packages, making pre-release packages ideal for limited user testing. <PackageVersion>1.0.1-beta1</PackageVersion> Note A stable package cannot depend on a pre-release package. You must either make your own package pre-release, or depend on an older stable version. ✔️ DO publish a pre-release package when testing, previewing, or experimenting. ✔️ DO publish a stable package when it is ready so other stable packages can reference it. More Information Building pre-release packages Symbol Packages NuGet supports generating a separate symbol package containing debug PDB files along side the main package containing .NET assemblies. The idea of symbol packages is they are hosted on a symbol server and are only downloaded by a tool like Visual Studio on demand. Currently the main public host for symbols - SymbolSource - does not support the portable PDBs created by SDK-style projects and symbol packages are not generally useful. ✔️ CONSIDER embedding PDBs in the main NuGet package. ❌ AVOID creating a symbols package containing PDBs. More Information Creating symbol packages"
  },
  "docs/dependencies.html": {
    "href": "docs/dependencies.html",
    "title": "Dependencies | The Book of .NET OSS",
    "keywords": "Dependencies The primary way of adding dependencies to a .NET library is referencing NuGet packages. NuGet package references allow you to quickly reuse and leverage already written functionality, but they are a common source of friction for .NET developers. Correctly managing dependencies is important to prevent changes in other .NET libraries from breaking your .NET library, and vice versa! Diamond dependencies It is a common situation for a .NET project to have multiple versions of a package in its dependency tree. For example, an app depends on two NuGet packages, each of which depends on different versions of the same package. This is known as a diamond dependency. At build time NuGet analyzes all the packages that a project depends on (including the dependencies of dependencies) and when multiple versions of a package is detected, rules are evaluated to pick one. Unifying packages is necessary because running side-by-side versions of an assembly is problematic in .NET. Most diamond dependencies are resolved without issue, however they can create issues in certain circumstances: Conflicting NuGet package references prevent a version from being resolved during package restore. Breaking changes between the versions causes bugs and exceptions at runtime. The package assembly is strong named , the assembly version changed, and the app is running on the .NET Framework. Assembly binding redirects are required. It is impossible to know what packages will be used alongside your own, but you can reduce the likelihood of a diamond dependency causing your library to break by minimizing the number of packages you depend on. ✔️ DO review your .NET library for unnecessary dependencies. NuGet dependency version ranges A package reference specifies the range of valid packages it allows. Typically, the package reference version in the csproj file is the minimum version and there is no maximum. <!-- Accepts any version 1.0 and above. --> <PackageReference Include=\"ExamplePackage\" Version=\"1.0\" /> The rules that NuGet uses when resolving dependencies are complex , but NuGet always attempts to find the lowest applicable version. NuGet prefers the lowest application version over using the highest available because the lowest will have the least compatibility issues. Because of NuGet's lowest application version rule, it is not necessary to place an upper version or exact range on package references to avoid getting the latest version. NuGet already tries to find the lowest, most compatible version for you. <!-- Accepts 1.0 up to 1.x, but not 2.0 and higher. --> <PackageReference Include=\"ExamplePackage\" Version=\"[1.0,2.0)\" /> <!-- Accepts exactly 1.0. --> <PackageReference Include=\"ExamplePackage\" Version=\"[1.0]\" /> Upper version limits will cause NuGet to fail if there is a conflict, e.g. one library accepts exactly 1.0 while another library requires 2.0 or above. While breaking changes may have been introduced in version 2.0, a strict or upper limit version dependency guarantees an error. ❌ DO NOT have NuGet package references with no minimum version. ❌ AVOID NuGet package references that demand an exact version. ❌ AVOID NuGet package references with a version upper limit. More Information How NuGet resolves package dependencies NuGet shared source packages One way to reduce external NuGet package dependencies is to reference share source packages. A shared source package contains source code files that are included in a project when referenced. Because you are just including source code files that are compiled with the rest of your project there is no external dependency and chance of conflict. Shared source packages are great for including small pieces of functionality, e.g. a shared source package containing helper methods for making HTTP calls. Shared source packages can only be used by PackageReference , and should be a private reference to tell NuGet it is only used at development time and should not be exposed to anyone using your package. <PackageReference Include=\"Microsoft.Extensions.Buffers.Testing.Sources\" PrivateAssets=\"All\" Version=\"1.0\" /> ✔️ CONSIDER referencing shared source packages for small, internal pieces of functionality. ✔️ CONSIDER making your package a shared source package if it provides small, internal pieces of functionality. ✔️ DO reference shared source packages with PrivateAssets=\"All\" . ❌ AVOID shared-source package types in your public API. Shared-source types are compiled into the referencing assembly and can't be exchanged across assembly boundaries, e.g. a shared-source IRepository type in one project is a separate type from the same shared-source IRepository in another project. More Information NuGet - Including content files Source Code Only NuGet Packages"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home | The Book of .NET OSS",
    "keywords": "The Book of .NET OSS Documentation for building wonderful .NET open source software. The goal of this website is to bring together best practices for .NET OSS, and provide a set of common recommendations for creating .NET OSS libraries. We want to help the OSS project owners and maintainers produce high quality, stable libraries for all .NET developers. Get started View documentation How Can I Help? Contribute your knowledge to the documentation. .NET is evolving rapidly and these docs need to stay up to date. Let developers know these docs exists when a question comes up. View source on GitHub . License The Book of .NET OSS is licensed under Creative Commons Attribution 4.0 International ."
  },
  "docs/nuget-publishing.html": {
    "href": "docs/nuget-publishing.html",
    "title": "Publishing a NuGet Package | The Book of .NET OSS",
    "keywords": "Publishing a NuGet Package NuGet packages are published and consumed from package repositories. While NuGet.org is the most widely known and used repository, there are many places to publish NuGet packages: NuGet.org is the primary online repository for NuGet packages. All packages on NuGet.org are publicly available to everyone. By default, Visual Studio has NuGet.org as a package source and for many developers this is the only package repository they will interact with. NuGet.org is the best place to publish stable packages and pre-release packages that you want community feedback on. MyGet repository service supports free custom package feeds for open source projects. A MyGet public custom feed is an ideal place to publish pre-release packages created by your CI service. MyGet also provides private feeds commercially. A local feed allows you to treat a folder like a package repository and makes the *.nupkg files in the folder accessible by NuGet. A local feed is useful for testing a NuGet package prior to publishing it to NuGet.org. Note Nuget.org does not allow a package to be deleted once it is uploaded. A package can be unlisted so that it is not publicly visible in the UI but the *.nupkg can still be downloaded on restore. Also, nuget.org does not allow duplicate package versions. To correct a NuGet package with an error you have to unlist the incorrect package, increment the version number and publish a new version of the package. ✔️ DO publish stable packages and pre-release packages you want community feedback on to NuGet.org. ✔️ CONSIDER publishing pre-release packages to a MyGet feed from a continuous integration build. ✔️ CONSIDER testing packages in your development environment using a local feed or MyGet before publishing to NuGet.org. More Information Publish a package to NuGet.org Deleting packages on NuGet.org MyGet open source offer NuGet local feeds Configure NuGet package sources NuGet.org Security It is important that bad actors cannot access your NuGet account and upload a malicious version of your library. NuGet.org offers two-factor authentication and email notifications when a package is published. Enable these features after logging into NuGet.org on the Account settings page. ✔️ DO use a Microsoft account to login to NuGet. ✔️ DO enable two factor authentication for accessing NuGet. ✔️ DO enable email notification when a package is published."
  },
  "docs/get-started.html": {
    "href": "docs/get-started.html",
    "title": "Get Started | The Book of .NET OSS",
    "keywords": "Get Started Your first steps to creating and publishing a .NET OSS project. Experienced OSS .NET developers can jump directly to the full documentation . Setup Download the tools useful for developing a .NET library: .NET Core SDK contains everything you need to compile a .NET library and NuGet package. Visual Studio Community is a fully featured IDE for Windows that is free for OSS projects. Visual Studio Code is a free cross-platform IDE. NuGet Package Explorer lets you view NuGet package metadata and content. Create a GitHub repository and choose an OSS license . Design and development Plan early for your library to be cross-platform . .NET runs in many places, the more people you can reach the better. Manage what dependencies your library will reference. There is a big eco-system of packages to use but dependencies are a common source of friction. Decide on strong naming your library. Packaging and publishing Create a NuGet package . NuGet is the primary way developers discover and acquired open source libraries. Enable SourceLink debugging for your package. Publish to NuGet.org . Future development Iterate and version your library. Learn about breaking changes . Do your best to minimize disruption to your users while fixing bugs and adding features. ✔️ DO host your project on GitHub or another online distributed source control service. ✔️ DO choose an OSS license . A project without a license defaults to exclusive copyright , making it impossible for other people to use. More Information Choose an open source license"
  },
  "docs/strong-naming.html": {
    "href": "docs/strong-naming.html",
    "title": "Strong Naming | The Book of .NET OSS",
    "keywords": "Strong Naming Strong naming refers to signing an assembly with a key, producing a strong named assembly. When an assembly is strong-named, it creates a unique identity based on the name and assembly version number, and can help prevent assembly conflicts. The downside to strong-naming is that the .NET Framework on Windows enables strict loading of assemblies once an assembly is strong named. A strong-named assembly reference must exactly match the version referenced by an assembly, forcing developers to configure binding redirects when using the assembly: <configuration> <runtime> <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"> <dependentAssembly> <assemblyIdentity name=\"myAssembly\" publicKeyToken=\"32ab4ba45e0a69a1\" culture=\"neutral\" /> <bindingRedirect oldVersion=\"1.0.0.0\" newVersion=\"2.0.0.0\"/> </dependentAssembly> </assemblyBinding> </runtime> </configuration> When .NET developers complain about strong-naming, what they are usually complaining about is strict assembly loading. Fortunately, this issue is isolated to the .NET Framework. .NET Core, Xamarin, UWP and most other .NET implementations do not have strict assembly loading and removes the main downside of strong-naming. One important aspect of strong naming is it is viral: a strong named assembly can only reference other strong named assemblies. If your library is not strong named then developers who are building an application or library that needs strong naming are excluded from using it. The benefits of strong naming are: The assembly can be referenced and used by other strong-named assemblies. The assembly can be stored in the Global Assembly Cache (GAC). The assembly can be loaded side-by-side with other versions of the assembly. This is commonly required by applications with plug-in architectures. What should I do? Applications don't need to strong name most of the time, but strong naming is recommended for .NET OSS libraries. Strong-naming a library's assembly ensures that the most people can use it, and only the .NET Framework is effected by strict assembly loading. ✔️ CONSIDER strong-naming your library's assemblies. ✔️ CONSIDER checking in the key used to strong-name into your source control system. A publicly available key lets developers modify and recompile your library source code with the same key. Note When a cryptographic identity is desired, Authenticode and NuGet Package Signing are recommended. Strong naming should not be used for security considerations. ✔️ CONSIDER incrementing the assembly version on only major version changes to help users reduce binding redirects, and how often they are updated. ❌ DO NOT publish strong-named and non-strong-named versions of your project, e.g. Contoso.Api and Contoso.Api.StrongNamed . Publishing two packages forks your developer eco-system. Also if an application ends up depending on both packages the developer can encounter type name conflicts. As far as .NET is concerned they are different types in different assemblies. More Information Strong-Named Assemblies Redirecting Assembly Versions"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | The Book of .NET OSS",
    "keywords": "Introduction This set of guidelines provides recommendations for developers to create high quality .NET libraries. This documentation focuses on the what and the why when building a .NET library, not the how . After each topic there are links to more information, usually to detailed documentation and references. Recommendations With each topic there is a list of recommendations for your OSS project using Do , Consider , Avoid and Do not . The wording of each recommendation indicates how strongly it should be followed. For example a Do recommendation is one that should almost always be followed: ✔️ DO choose an OSS license . On the other hand Consider recommendations should generally be followed, but there are legitimate exceptions to the rule and you should not feel bad about not following the guidance: ✔️️ CONSIDER using SemVer 2.0.0 to version your NuGet package. Do not indicates something you should almost never do: ❌ DO NOT publish strong-named and non-strong-named versions of your project, e.g. Contoso.Api and Contoso.Api.StrongNamed . And finally less strong, avoid recommendations are something this is not a good idea, but breaking the rule sometimes makes sense: ❌ AVOID NuGet package references that demand an exact version."
  },
  "docs/cross-platform-targeting.html": {
    "href": "docs/cross-platform-targeting.html",
    "title": "Cross-platform Targeting | The Book of .NET OSS",
    "keywords": "Cross-platform Targeting The modern .NET ecosystem supports multiple operating systems and devices. It is important for .NET OSS projects to support as wide a range of developers as possible, whether they are building an ASP.NET website hosted in Azure, or a .NET game in Unity. .NET Standard .NET Standard is the best way to add cross-platform support to a .NET library. .NET Standard is a specification of .NET APIs that are available on all .NET implementations. Targeting a .NET Standard lets you produce a library that is usable by all platforms that support that version of .NET Standard. Targeting .NET Standard, and successfully compiling your project, does not guarantee the library will run successfully on all platforms: Platform specific APIs will fail on other platforms, e.g. Microsoft.Win32.Registry will succeed on Windows and throw PlatformNotSupportedException when used on any other OS. APIs can behave differently, e.g. reflection APIs have different performance characteristics when an application uses ahead-of-time compilation on iOS or UWP. Tip The .NET team offers a Roslyn analyzer to help you discover possible issues. ✔️ DO start with including a netstandard2.0 target. Most general purpose libraries should not need APIs outside of .NET Standard 2.0. .NET Standard 2.0 is supported by all modern platforms and is the recommended way to support multiple platforms with one target. ❌ AVOID including a netstandard1.x target. A .NET Standard 1.x is distributed as a granular set of NuGet packages, which creates large package dependency graph and results in developers downloading a lot of packages when building. Modern .NET platforms, including .NET Framework 4.6.1, UWP and Xamarin, all support .NET Standard 2.0. You should only target .NET Standard 1.x if you specifically need to target an older platform. If you do have a .NET Standard 1.x target then also include a 2.0 target. Modern platforms will use the 2.0 target and older platforms will fall back to 1.x. ❌ DO NOT include a .NET Standard target if the library relies on a platform specific app model. For example, a UWP control toolkit library depends on an app model that is only available on UWP. App model specific APIs will not be available in .NET Standard. More Information .NET Standard .NET API analyzer Multi-targeting An alternative way to add cross-platform support to a .NET library is multi-targeting. Multi-targeting involves targeting .NET implementations individually and includes multiple assemblies in a NuGet package. This leverages NuGet's ability to have multiple assemblies in a package and select the best one when added to an application. You can combine multi-targeting with .NET Standard. For example, a netstandard2.0 target could be the default implementation and you could provide a .NET implementation specific target that uses implementation specific APIs for additional features. NuGet will automatically select the implementation specific target when possible, e.g. a .NET Core application will use the netcoreapp2.0 assembly over the netstandard2.0 assembly in a NuGet package. ✔️ CONSIDER targeting .NET implementations in addition to .NET Standard. Targeting .NET implementations allows you to call platform-specific APIs that are outside of .NET Standard. Do not drop support for .NET Standard when you do this. Instead, throw from the implementation and offer capability APIs. This way, your library can be used anywhere and supports runtime light-up of features. ❌ DO NOT use multi-targeting with .NET Standard if your source code is the same for all targets. The .NET Standard assembly will automatically be used by NuGet. Targeting individual .NET implementations increases the *.nupkg size for no benefit. ✔️ CONSIDER adding a target for net461 when you're offering a netstandard2.0 target. Using .NET Standard 2.0 from .NET Framework has some issues that were addressed in .NET Framework 4.7.2. You can improve the experience for developers that are still on .NET Framework 4.6.1 - 4.7.1 by offering them a binary that is built for .NET Framework 4.6.1. ✔️ DO distribute your library using a NuGet package. NuGet will select the best target for developer and shield them having to pick the appropriate implementation. ✔️ DO use a project file's TargetFrameworks property when multi-targeting. <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <!-- This project will output netstandard2.0 and net471 assemblies --> <TargetFrameworks>netstandard2.0;net471</TargetFrameworks> </PropertyGroup> </Project> More Information .NET target frameworks Multi-Targeting and Porting a .NET Library to .NET Core 2.0 Older Targets .NET supports targeting versions of the .NET Framework that are long out of support, e.g. .NET 2.0, as well as platforms that are no longer commonly used, e.g. Silverlight and Windows Phone. The value of targeting such old platforms can be easily outweighed by the overhead of programming around missing APIs. ❌ DO NOT include a Portable Class Library (PCL) target, e.g. portable-net45+win8+wpa81+wp8 . .NET Standard is the modern way to support cross-platform .NET libraries and replaces PCLs. ❌ DO NOT include targets for .NET platforms that are no longer supported, e.g. SL4 , WP ."
  },
  "docs/sourcelink.html": {
    "href": "docs/sourcelink.html",
    "title": "SourceLink | The Book of .NET OSS",
    "keywords": "SourceLink SourceLink is a technology that enables source code debugging of .NET assemblies from NuGet by developers. When creating a NuGet package you use the SourceLink tooling to embed source control metadata inside assemblies and the package. Developers who download the package and have SourceLink enabled in Visual Studio can step into the source code using the source control metadata to create a great debugging experience. Using SourceLink Instructions for using SourceLink can be found on the SourceLink GitHub repository . You can use NuGet Package Explorer to confirm SourceLink metadata has been successfully embedded in the package: ✔️ CONSIDER using SourceLink to add source control metadata to your assemblies and NuGet package. ✔️ CONSIDER including PDB files in the NuGet package."
  },
  "docs/breaking-changes.html": {
    "href": "docs/breaking-changes.html",
    "title": "Breaking Changes | The Book of .NET OSS",
    "keywords": "Breaking Changes It is important for an OSS project to find a balance between stability for existing users and innovation for the future. As developers, we lend towards refactoring and rethinking code until it is perfect, but breaking your existing users has a negative impact, especially for low-level libraries. Project types and breaking changes How a project is used by the .NET community changes the effect of breaking changes on end user developers. Low and middle-level libraries like a serializer, HTML parser, DB ORM, or web framework are the most impacted by breaking changes. These building block packages are used both by end user developers to build applications, and by other OSS projects as NuGet dependencies. For example, if you are building an application and are using an OSS client to call a web service, and the HTTP library the client uses is updated with a breaking change, you have no way to directly fix the OSS client because it is code you don't own. You must either find compatible versions of the client and HTTP library, or submit a fix to the OSS client and wait for a new version. The worst-case situation is if you want to use two OSS projects that depend on mutually incompatible versions of a third library. High level libraries like a suite of UI controls are less sensitive to breaking changes. Because a high-level library is likely to be directly referenced in the end user application, in the event of breaking changes the developer can choose to not update to the latest version, or can modify their application to work with the breaking change. ✔️ DO what you can to minimise breaking changes when developing a low-level .NET library. ✔️ CONSIDER publishing a major rewrite of a library as a new NuGet package. Types of Breaking Changes Breaking changes fall into different categories and are not equally impactful. Source Breaking Change A source breaking change doesn't affect program execution but will cause compilation errors the next time the application is recompiled. Examples of source breaking changes include adding a new overload that can result in ambiguity in method calls that were unambiguous previously, or changing a parameter name that can break anyone calling that method using named parameters. public class Task { // Adding a type called Task could conflict with System.Threading.Task at compilation } Because a source breaking change is only harmful when the developer recompiles their application, it is the least disruptive. Developers can fix their own broken source code easily. Behavior Breaking Change Behavior changes are the most common breaking change: almost any change in behavior could break someone. Even a bug fix can qualify if users relied on the previously broken behavior. ✔️ CONSIDER leaving new features off by default if they affect existing users, and let developers opt-in to the feature with a setting. Binary Breaking Change A binary breaking change happens when you change the public API of a library so that assemblies compiled against older versions are no longer able to call it. For example, changing a method's signature by adding a new parameter will cause already compiled assemblies that called it to throw a MissingMethodException . A binary breaking change can also break an entire assembly . Renaming an assembly in AssemblyNameAttribute , adding, removing or changing an assembly's strong naming key changes the assembly identity, and all compiled code that uses it will fail. ❌ DO NOT change an assembly name. ❌ DO NOT add, remove or change the strong naming key. ✔️ CONSIDER using abstract base classes instead of interfaces. Adding anything to an interface will cause existing types that implement it to fail. An abstract base class allows you to add a default virtual implementation. ✔️ CONSIDER placing the ObsoleteAttribute on types and members that you intend to remove with instructions for fixing their code to no longer use the obsolete API. Code that calls types and methods with the ObsoleteAttribute will generate a build warning with the message supplied to the attribute. The warnings give people who use the obsolete API surface time to migrate so that when the obsolete API is removed, most are no longer be using it. public class Document { [Obsolete(\"LoadDocument(string) is obsolete. Use LoadDocument(Uri) instead.\")] public static Document LoadDocument(string uri) { return LoadDocument(new Uri(uri)); } public static Document LoadDocument(Uri uri) { // Load the document } } More Information A definitive guide to API-breaking changes in .NET CoreFX Breaking Change Rules"
  },
  "docs/versioning.html": {
    "href": "docs/versioning.html",
    "title": "Versioning | The Book of .NET OSS",
    "keywords": "Versioning It is rare for an OSS project to have one release so you must think about how you will go about releasing new versions. Breaking Changes Handling breaking changes between versions is covered in detail here . Version Numbers A .NET library has many ways to specify a version. These are the most important: NuGet Package Version The NuGet package version is what is displayed on nuget.org, the Visual Studio NuGet UI, and is written to package.config / *.csproj when the packaged is used. This version number is what users will commonly see and refer to when they think and talk about the version of a library they are using. The NuGet package version is used by NuGet and has no effect on runtime behavior. <PackageVersion>1.0.0-alpha1</PackageVersion> The NuGet package identifier, e.g. Newtonsoft.Json, combined with the NuGet package version, e.g. 11.0.2, is used to uniquely identify a package in NuGet. A package with a suffix is a pre-release package and has special behavior that makes it ideal for testing. Read about pre-release NuGet packages here . Because the NuGet package version is the most visible version to developers, it is a good idea to update it using Semantic Versioning (SemVer) . SemVer indicates the significance of changes between release (e.g. 1.0 to 2.0 indicates that there are breaking changes) and helps developers make an informed decision when choosing what version to use. ✔️ CONSIDER using SemVer 2.0.0 to version your NuGet package. ✔️ DO use the NuGet package version number in public communication and documentation as it is the version number that users will commonly see. ✔️ DO include a pre-release suffix when releasing a non-stable package. Users must opt-in to getting pre-release packages so they will understand that the package is not complete. More information NuGet package versioning Semantic Versioning 2.0.0 Assembly Version The assembly version is what the CLR uses at runtime to select which version of an assembly to load. Selecting an assembly using versioning only applies to assemblies with a strong name. <AssemblyVersion>1.0.0.0</AssemblyVersion> By default, the Windows .NET Framework CLR demands an exact match when loading a strong named assembly, e.g. Libary1, Version=1.0.0.0 was compiled with a reference to Newtonsoft.Json, Version=11.0.0.0 and will only load that exact version 11.0.0.0. To load a different version at runtime, a binding redirect must be added to the .NET application's config file. Strong naming combined with assembly version is a controversial subject. While strong naming a library has a number of benefits, it often results in runtime exceptions that an assembly can't be found and requires binding redirects in app.config / web.config to be fixed. .NET Core assembly loading has been relaxed, and the .NET Core CLR will automatically load assemblies at runtime with a higher version. ✔️ CONSIDER only including a major version in the AssemblyVersion. e.g. Library 1.0 and Library 1.0.1 both have an AssemblyVersion of 1.0.0.0 , while Library 2.0 has AssemblyVersion of 2.0.0.0 . When the assembly version changes less often, it reduces binding redirects. ✔️ CONSIDER keeping the major verson number of the AssemblyVersion and the NuGet package version in sync. The AssemblyVerson is included in some informational messages displayed to the user, e.g. the assembly name and assembly qualified type names in exception messages. Maintaining a relationship between the versions provides more information to developers about which version they are using. ❌ DO NOT have a fixed AssemblyVersion. While an unchanging AssemblyVersion avoids the need for binding redirects, it means that only a single version of the assembly can be GACed. Also, the applications that reference the assembly in the GAC will break if another application updates the GACed assembly with breaking changes. More information Assembly versioning Redirecting Assembly Versions Assembly File Version The assembly file version is used to display a file version in Windows and has no effect on runtime behavior. Setting this version is optional. It is visible in the File Properties dialog in Windows Explorer: <FileVersion>11.0.2.21924</FileVersion> ✔️ CONSIDER including a continuous integration build number as AssemblyFileVersion revision. e.g. you are building version 1.0.0 of your project, and the continuous integration build number is 99 so your AssemblyFileVersion is 1.0.0.99. Assembly Informational Version The assembly informational version is used to record additional version information and has no effect on runtime behavior. Setting this version is optional. If you are using SourceLink, this version will automatically be included on build to contain the NuGet package version plus a source control version, e.g. the git commit hash the assembly was built from. Read more about SourceLink here . <AssemblyInformationalVersion>The quick brown fox jumped over the lazy dog.</AssemblyInformationalVersion> Note An innocuous build warning is raised if this version does not follow the format Major.Minor.Build.Revision . The warning can be safely ignored. ❌ AVOID setting the assembly informational version yourself. Allow SourceLink to automatically generate the version containing NuGet and source control metadata."
  }
}