# Strong Naming

Strong-naming assemblies is a controversial subject in the .NET community. There are definite benefits and definite costs to strong-naming, and there is constant debate over whether open source libraries should be strong-named.

## What is strong naming

A strong named assembly is generated by signing the assembly with a key. When an assembly is strong-named it creates a unique identity and can help prevent assembly conflicts.

The downside to strong-naming is strict loading of assemblies by the old .NET Framework on Windows kicks in once an assembly is strong named. A strong-named assembly reference must exactly match the version referenced by an assembly, forcing developers to configure binding redirects when using the assembly:

```xml
<configuration>
   <runtime>
      <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
         <dependentAssembly>
            <assemblyIdentity name="myAssembly" publicKeyToken="32ab4ba45e0a69a1" culture="neutral" />
            <bindingRedirect oldVersion="1.0.0.0" newVersion="2.0.0.0"/>
         </dependentAssembly>
      </assemblyBinding>
   </runtime>
</configuration>
```

When .NET developers complain about strong-naming what they are usually complaining about is strict assembly loading. Fortunately .NET Core relaxes this restriction and removes the main downside of strong-naming.

The benefits of strong naming are it provides a guarantee of identity (provided you choose to keep the private key secret), it allows the assembly to be stored in the Global Assembly Cache (GAC), it allows the assembly to be used by plug-in architectures that require strong naming, and it can be referenced by other strong named assemblies.

## What should I do?

Strong-naming an assembly ensures the most people can use it, and .NET Core removes the main problem with strong-naming.

**✓ CONSIDER** strong-naming your project assemblies. Strong-naming allows assemblies to be:

  1. Referenced by other strong-named assemblies
  2. Stored and referenced in the Global Assembly Cache (GAC)
  3. Used by applications with plug-in architectures that require strong-named assemblies

**✓ CONSIDER** checking in the key used to strong-name into your source control system. You loose the benefit of identity of strong-naming but making the key public lets developers recompile the library with the same identity.

**✓ CONSIDER** incrementing the assembly version on only major version changes to help users reduce binding redirects, and how often they are updated.

**X DO NOT** publish strong-named and non-strong-named versions of your project, e.g. `Contoso.Api` and `Contoso.Api.StrongNamed`. If an application ends up depending on both packages the developer will encounter type name conflicts.